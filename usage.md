# 使い方

## 原則

- 雰囲気で使う。
- とりあえず `examples/*.s` を見てみる。`test.sh`も参考になる。
- 分からなければソースコードを見る。
- 面倒なら[anqou](https://twitter.com/ushitora_anqou)に聞く。

## チュートリアル

- とりあえずビルドする。
    - `cd src/`して`make`すると`macro`, `assembler`, `emulator`, `debugger`, `encoder`ができる。
    - `macro`はマクロアセンブラ。SIMPLEのISAを適宜変更・拡張したうえで、マクロを使用可能にしている。基本的にこれでプログラミングすることを想定している。`examples/*.s`はこれに食わせる形式。標準入力から入力を取り、標準出力に出力する。
    - `assembler`はSIMPLE公式（＋α）準拠のアセンブラ。入力はSIMPLEの形式（`#`, `;`, `/`で始まるコメントは一部許容）。出力はビッグエンディアンの機械語（デフォルト）かMIF形式（オプション`-mif`）かを選べる。標準入力から入力を取り、標準出力に出力する。
    - `emulator`はSIMPLE公式（＋α）準拠の機械語（ただしビッグエンディアンを仮定）のためのエミュレータ。標準入力から入力を取り`HLT`が実行された段階での`R0`の値を戻り値（`$?`）とする。`OUT`による出力はその都度標準出力に出力される。
    - `debugger`はSIMPLE公式（＋α）準拠のデバッガ。マクロアセンブリを入力する場合は、ラッパの`aqdb.sh`を使用する。対話形式でステップ実行が可能。都度レジスタの中身やSZCVフラグの中身が表示される。`macro`の出力を入力する場合はブレークポイントを仕掛け、それが実行されるまでの連続実行が可能。`debugger`の入力は標準入力から取る。一方`aqdb.sh`はコマンドライン引数からマクロアセンブリのファイル名を取る。
    - `encoder`はテストのためのヘルパ。通常使用しない。詳しくは`test.sh`などを参照。
- 雰囲気を掴むために`examples/fiblt55.s`をアセンブルしてみる。
    - `cd src/`
    - `cat ../examples/fiblt55.s`すると`fiblt55.s`の中身が表示される。これ自体はマクロアセンブリにより表記されているため、そのままではアセンブラが解釈できない。
    - `cat ../examples/fiblt55.s | ./macro`としてマクロアセンブリにこれを食わせると、SIMPLEに準拠したアセンブリが出力される。
    - `cat ../examples/fiblt55.s | ./macro | ./assembler -mif`としてアセンブラにこれを入力し出力形式をMIF形式とすると、先程のアセンブリに対応する機械語がMIF形式で出力される。これをCPUのIMなどにコピペして用いる。
    - `cat ../examples/fiblt55.s | ./macro | ./assembler | ./emulator`とするとエミュレータがこれを実行する。今回の場合であれば55より小さいフィボナッチ数列が表示される。また、実行の終わりに表示される`#insts: 63`は、実行した合計の命令数が63個であったことを示している。なお`$?`は終了時の`R0`の値すなわち55となる。
    - `./aqdb.sh ../examples/fiblt55.s`とするとデバッガが起動する。はじめに実行箇所がSIMPLE準拠のアセンブリとマクロアセンブリで表示される。そのあとにレジスタの内容とSZCVフラグの内容が表示される。ここでEnterキーを押すと1ステップ実行が進む。Enterキーを押すたびに命令が実行され、それに従ってレジスタの中身が書き換わるのが確認できる。次にブレークポイントを仕掛ける。`b 12`と入力すると、マクロアセンブリの12行目に処理が移るまで実行を継続する。`fiblt55.s`では12行目は`HLT`命令であるので、次にEnterを押すとプログラムが終了する一歩手前まで処理が進むことになる。デバッガを終了する際には`q`と打ち込み改行する。

## マクロアセンブラ

再度フィボナッチ数列の例を取る。SIMPLE公式の枠組みで55未満のフィボナッチ数列を表示する
アセンブリを書くと、おおよそ次のようになる：

```
LI R0, 0
LI R1, 1
LI R4, 55
OUT R0
MOV R3, R1
ADD R1, R0
MOV R0, R3
CMP R0, R4
BLT -6
HLT
```

およそ令和に人間が書くべきコードではない。（このコードに限らず）SIMPLE公式に準拠したアセンブリの不満点を挙げると：

- レジスタへの代入元に応じて命令を変える必要がある（即値なら`LI`, レジスタなら`MOV`, メモリなら`LD`）。
- `LD`, `ST`の記法が煩雑。
- ブランチ命令の相対アドレスを数える必要がある。
- コード中に埋め込まれている定数（上のコードなら`0`, `1`, `55`など）がどのような意味を持つのか、一目では判断がつかない。
- 演算が前置記法で見にくい。
- 条件分岐に2命令（例えば`CMP`と`BLT`）必要。

などが一例であろう。これらの問題を解決するのがマクロアセンブラ（`macro`）である。

マクロアセンブラでは：

- `LI`, `MOV`, `LD`, `ST`をすべて`MOV`で行うことができる。
- メモリアドレスの指定を`[Rd + imm]`の形式で行うことができる。
- ブランチ命令に指定するためのラベルを設置することができる。

以上の機能を用いて先程のコードを書き直すと次のようになる：

```
	MOV R0, 0
	MOV R1, 1
	MOV R4, 55
loop:
	OUT R0
	MOV R3, R1
	ADD R1, R0
	MOV R0, R3
	CMP R0, R4
	JL  loop
exit:
	HLT
```

先程のコードにあった問題が一部解決していることがわかるだろうか。

さて残りの問題を解決するために「マクロ」を使用する。
マクロとは、ある決まった文字列（トークン）の並びに別の名前をつけるための機能である。

ユーザがマクロを定義する場合`define name values...`の記法を用いる。
これにより、コード中の`name`が全て`values...`に展開される。なお多重展開には対応していない。

```
define A 42
MOV R0, A   # R0には42が格納される。
```

ユーザが定義するマクロとは別に、マクロアセンブラが定義するマクロもある
（ただし、これらはむしろ構文糖衣（シンタックス・シュガー）と呼ばれるべきものである）。
次に一覧する：

- `A = B`
    - `MOV A, B`と展開される。
- `A += B`
    - `ADD A, B`と展開される。`-=`, `<<=`, `>>=`, `&=`, `|=`について同様。
- `goto label`
    - `JMP label`と展開される。
- `if A == B then goto label`
    - `CMP A, B（改行）JE label`と展開される。`!=`, `<`, `<=`について同様。

これらを用いると、55未満のフィボナッチ数列を表示するアセンブリは次のように書くことができる：

```
    define SUP 55
    define A0 0
    define A1 1

    R0 = A0
    R1 = A1
    R4 = SUP
loop:
    OUT R0
    R3 = R0
    R0 = R1
    R1 += R3
    if R0 < R4 then goto loop
exit:
    HLT
```

これで当初のコードにあった問題はすべて解決した。

## 便利機能

### 初期DM配置

ソートプログラムのエミュレートを行う際などに、DM上にメモリデータを展開したい場合がある。
このときは、まずメモリデータを表すMIFを`mif2bin.rb`に通してバイナリファイルを作成し、
そのバイナリファイルを`emulator`に`-m`オプションを用いて渡す。
また、最終的なメモリの状態を表示させたい場合は`-d`オプションを指定する。
従って次のようになる：`./emulator -d -m hoge.membin`

なお`debugger`は現状この機能に対応していない（TODO）。

## `macro` で使える命令リファレンス

随時増えます。一般論としてドキュメントが整備されるのは実装が行われて
少し経ってからなので、最新の仕様が知りたいときはソースコードを読みましょう。
あるいは自分で実装しましょう。

具体的な使い方は `examples/*.s` とか `src/test.sh` とかを調べると良いかも知れません。

凡例：

- `macroに食わせる入力`
    - `macroが吐く出力 or assemblerに食わせる入力`
    - 注意など

一般的に`Rn/Rm`はレジスタをさし`imm`は即値をさし、`label`はラベルをさします。
`imm`には10進数のほか`0x`を先頭につけることで16進数が使えます。

- `ADD Rn, Rm`
    - `ADD Rn, Rm`
    - `SUB`, `CMP`, `AND`, `OR`, `XOR`, `CMP`, `MOV`について同様。
- `ADD Rn, imm`
    - `ADDI Rn, imm`
    - `CMPI`について同様。
- `MOV Rn, imm`
    - `LI Rn, imm`
- `MOV Rn, [Rm + imm]`
    - `LD Rn, imm(Rm)`
    - `imm`は省略可能。`+`の代わりに`-`も使用可能。
- `MOV [Rn + imm], Rm`
    - `ST Rm, imm(Rn)`
    - `imm`は省略可能。`+`の代わりに`-`も使用可能。
- `Rn = Rm`
    - `MOV Rn, Rm`
- `[Rn + imm] = Rm`
    - `ST Rm, imm(Rn)`
- `Rn = [Rm + imm]`
    - `LD Rn, imm(Rm)`
- `SLL Rn, imm`
    - `SLL Rn, imm`
    - `SLR`, `SRL`, `SRA`について同様。
- `IN Rn`
    - `IN Rn`
    - `OUT`について同様。
- `HLT`
    - `HLT`
- `JMP label`
    - `B labelへの相対アドレス`
- `goto label`
    - `B labelへの相対アドレス`
- `JE label`
    - `BE labelへの相対アドレス`
- `JL label`
    - `BL labelへの相対アドレス`
- `JLE label`
    - `BLE labnelへの相対アドレス`
- `JNE label`
    - `BNE labelへの相対アドレス`
- `if Rn == Rm then goto label`
    - `CMP Rn, Rm（改行）BE labelへの相対アドレス`
    - `Rn == Rm` という条件が成立するときに`label`へ飛ぶようなアセンブリを出力する。なお`!=`の他`<`, `<=`についても同様。
- `define name body`
    - なし。
    - マクロを定義できる。すなわち、この行よりあとの全ての`name`は`body`に置換される。`examples/fibonmem_macro.s`などを参照のこと。

## バグかな？と思ったら

Issueをぶっ立てるか anqou に相談するかソースコード読んで自分で解決するかしてください。
自分で解決した場合はPull Requestを送ってもらえると私を含めSIMPLE-arch-toolsを使う
全ての人が助かります。
