# 使い方

## 原則

- 雰囲気で使う。
- とりあえず `examples/*.s` を見てみる。`test.sh`も参考になる。
- 分からなければソースコードを見る。
- 面倒なら[anqou](https://twitter.com/ushitora_anqou)に聞く。
- Linux（というか\*nix）の基本的な使い方は[ここらあたり](https://anqou.net/poc/2018/02/12/post-1085/)を参考のこと。

## チュートリアル

- とりあえずビルドする。
    - `cd src/`して`make`すると`macro`, `assembler`, `emulator`, `debugger`, `encoder`ができる。
    - `macro`はマクロアセンブラ。SIMPLEのISAを適宜変更・拡張したうえで、マクロを使用可能にしている。基本的にこれでプログラミングすることを想定している。`examples/*.s`はこれに食わせる形式。標準入力から入力を取り、標準出力に出力する。
    - `assembler`はSIMPLE公式（＋α）準拠のアセンブラ。入力はSIMPLEの形式（`#`, `;`, `/`で始まるコメントは一部許容）。出力はビッグエンディアンの機械語（デフォルト）かMIF形式（オプション`-mif`）かを選べる。標準入力から入力を取り、標準出力に出力する。
    - `emulator`はSIMPLE公式（＋α）準拠の機械語（ただしビッグエンディアンを仮定）のためのエミュレータ。標準入力から入力を取り`HLT`が実行された段階での`R0`の値を戻り値（`$?`）とする。`OUT`による出力はその都度標準出力に出力される。
    - `debugger`はSIMPLE公式（＋α）準拠のデバッガ。マクロアセンブリを入力する場合は、ラッパの`aqdb.sh`を使用する。対話形式でステップ実行が可能。都度レジスタの中身やSZCVフラグの中身が表示される。`macro`の出力を入力する場合はブレークポイントを仕掛け、それが実行されるまでの連続実行が可能。`debugger`の入力は標準入力から取る。一方`aqdb.sh`はコマンドライン引数からマクロアセンブリのファイル名を取る。
    - `compiler`はC-likeなプログラムを`macro`のアセンブリに変換するコンパイラである。詳細は以下のチュートリアルや`examples/*.c`, `examples/saizeriya/`などを参照すること。
    - `encoder`はテストのためのヘルパ。通常使用しない。詳しくは`test.sh`などを参照。
- 雰囲気を掴むために`examples/fiblt55.s`をアセンブルしてみる。
    - `cd src/`
    - `cat ../examples/fiblt55.s`すると`fiblt55.s`の中身が表示される。これ自体はマクロアセンブリにより表記されているため、そのままではアセンブラが解釈できない。
    - `cat ../examples/fiblt55.s | ./macro`としてマクロアセンブリにこれを食わせると、SIMPLEに準拠したアセンブリが出力される。
    - `cat ../examples/fiblt55.s | ./macro | ./assembler -mif`としてアセンブラにこれを入力し出力形式をMIF形式とすると、先程のアセンブリに対応する機械語がMIF形式で出力される。これをCPUのIMなどにコピペして用いる。
    - `cat ../examples/fiblt55.s | ./macro | ./assembler | ./emulator`とするとエミュレータがこれを実行する。今回の場合であれば55より小さいフィボナッチ数列が表示される。また、実行の終わりに表示される`#insts: 63`は、実行した合計の命令数が63個であったことを示している。なお`$?`は終了時の`R0`の値すなわち55となる。
    - `./aqdb.sh ../examples/fiblt55.s`とするとデバッガが起動する。はじめに実行箇所がSIMPLE準拠のアセンブリとマクロアセンブリで表示される。そのあとにレジスタの内容とSZCVフラグの内容が表示される。ここでEnterキーを押すと1ステップ実行が進む。Enterキーを押すたびに命令が実行され、それに従ってレジスタの中身が書き換わるのが確認できる。次にブレークポイントを仕掛ける。`b 12`と入力すると、マクロアセンブリの12行目に処理が移るまで実行を継続する。`fiblt55.s`では12行目は`HLT`命令であるので、次にEnterを押すとプログラムが終了する一歩手前まで処理が進むことになる。デバッガを終了する際には`q`と打ち込み改行する。

## マクロアセンブラ

再度フィボナッチ数列の例を取る。SIMPLE公式の枠組みで55未満のフィボナッチ数列を表示する
アセンブリを書くと、おおよそ次のようになる：

```
LI R0, 0
LI R1, 1
LI R4, 55
OUT R0
MOV R3, R1
ADD R1, R0
MOV R0, R3
CMP R0, R4
BLT -6
HLT
```

およそ令和に人間が書くべきコードではない。（このコードに限らず）SIMPLE公式に準拠したアセンブリの不満点を挙げると：

- レジスタへの代入元に応じて命令を変える必要がある（即値なら`LI`, レジスタなら`MOV`, メモリなら`LD`）。
- `LD`, `ST`の記法が煩雑。
- ブランチ命令の相対アドレスを数える必要がある。
- コード中に埋め込まれている定数（上のコードなら`0`, `1`, `55`など）がどのような意味を持つのか、一目では判断がつかない。
- 演算が前置記法で見にくい。
- 条件分岐に2命令（例えば`CMP`と`BLT`）必要。

などが一例であろう。これらの問題を解決するのがマクロアセンブラ（`macro`）である。

マクロアセンブラでは：

- `LI`, `MOV`, `LD`, `ST`をすべて`MOV`で行うことができる。
- メモリアドレスの指定を`[Rd + imm]`の形式で行うことができる。
- ブランチ命令に指定するためのラベルを設置することができる。

以上の機能を用いて先程のコードを書き直すと次のようになる：

```
	MOV R0, 0
	MOV R1, 1
	MOV R4, 55
loop:
	OUT R0
	MOV R3, R1
	ADD R1, R0
	MOV R0, R3
	CMP R0, R4
	JL  loop
exit:
	HLT
```

先程のコードにあった問題が一部解決していることがわかるだろうか。

さて残りの問題を解決するために「マクロ」を使用する。
マクロとは、ある決まった文字列（トークン）の並びに別の名前をつけるための機能である。

ユーザがマクロを定義する場合`define name values...`の記法を用いる。
これにより、コード中の`name`が全て`values...`に展開される。なお多重展開には対応していない。

```
define A 42
MOV R0, A   # R0には42が格納される。
```

ユーザが定義するマクロとは別に、マクロアセンブラが定義するマクロもある
（ただし、これらはむしろ構文糖衣（シンタックス・シュガー）と呼ばれるべきものである）。
次に一覧する：

- `A = B`
    - `MOV A, B`と展開される。
- `A += B`
    - `ADD A, B`と展開される。`-=`, `<<=`, `>>=`, `&=`, `|=`について同様。
- `goto label`
    - `JMP label`と展開される。
- `if A == B then goto label`
    - `CMP A, B（改行）JE label`と展開される。`!=`, `<`, `<=`について同様。

これらを用いると、55未満のフィボナッチ数列を表示するアセンブリは次のように書くことができる：

```
    define SUP 55
    define A0 0
    define A1 1

    R0 = A0
    R1 = A1
    R4 = SUP
loop:
    OUT R0
    R3 = R0
    R0 = R1
    R1 += R3
    if R0 < R4 then goto loop
exit:
    HLT
```

これで当初のコードにあった問題はすべて解決した。

――解決したのだが、人は一般に「具体的にどのレジスタを使うか」などは気にしたくないものである。

```
    define SUP 55
    define A0 0
    define A1 1

    alloc a0, a1, tmp, sup
    a0 = A0
    a1 = A1
    sup = SUP

loop:
    OUT a0
    tmp = a0
    a0 = a1
    a1 += tmp
    if a0 < sup then goto loop
exit:
    halt
```

`alloc`を使って「どのレジスタを使うか」ということを気にしないコードを書くことができた。
――できたのだが、やはりまだ分かりにくい。その一端は`tmp`という一時変数がコード全体で使えるためではないだろうか。
間違いなく、多分、きっと、おそらく、そうだ。ということでこれを解決する。

```
inline fib_loop(a0, a1, sup) {
    super a0, a1, sup
    alloc tmp

loop:
    OUT a0
    tmp = a0
    a0 = a1
    a1 += tmp
    if a0 < sup then goto loop
}

    define SUP 55
    define A0 0
    define A1 1

    alloc a0, a1, sup
    a0 = A0
    a1 = A1
    sup = SUP
    fib_loop(a0, a1, sup)
    halt
```

わかりやすくなった――気がする。

というかそもそもこの令和にアセンブリを書くこと自体がナンセンスである。コンパイラは無いのか――有る。

```
int a0, a1, sup;
a0 = 0;
a1 = 1;
sup = 55;

while(a0 < sup) {
    __builtin_output(a0);
    int tmp;
    tmp = a0;
    a0 = a1;
    a1 = a1 + tmp;
}

__builtin_halt();
```

次のようにしてコンパイルし、アセンブルし、エミュレートする。

```
cat fib.c | ./compiler | ./macro | ./assembler | ./emulator
```

これぞ令和に恥じないプログラミングである。知らんけど。
ちなみにこのコンパイラに最適化機能はない。`#insts`の値が極端に増加していることに注意せよ。

## Tips

### 初期DM配置

ソートプログラムのエミュレートを行う際などに、DM上にメモリデータを展開したい場合がある。
このときは、まずメモリデータを表すMIFを`mif2bin.rb`に通してバイナリファイルを作成し、
そのバイナリファイルを`emulator`に`-m`オプションを用いて渡す。
また、最終的なメモリの状態を表示させたい場合は`-d`オプションを指定する。
従って次のようになる：
```
$ ruby mif2bin.rb random.mif random.membin
$ cat ../examples/radix_sort1bit.s | ./macro | ./assembler | ./emulator -d -m random.membin | less
```

なお同様に`debugger`にも`-m`オプションがあり、DMの初期配置を入力することができる。これは後述する。

### デバッガ

`debugger`はアセンブリコードのためのデバッガである。主に`macro`が出力したアセンブリコードを
デバッグすることを想定している。`debugger`を使うと、マクロアセンブリコードのステップ実行や
ブレークポイントを仕掛けてのジャンプを行うことができ、その都度どの命令が実行されているか・
レジスタの値がどのようになっているかを確認することができる。

`debugger`自体は（マクロではない）アセンブリコードを入力としてとるため、少々扱いが厄介である。
そこで`aqdb.sh`をラッパとして使用する。例えば`examples/fiblt55.s`をデバッガ上で実行するには
次のようにする
```
$ ./aqdb.sh ../examples/fiblt55.s
```

デバッガ上では一行目に命令の位置と命令の内容が表示される。
左側に（マクロではない）アセンブリ、右側にマクロアセンブリが表示される。
その下にレジスタの中身とSZCVフラグの中身が表示される。

何も入力せずに`Enter`を押すと、今表示されている命令が実行され、次の命令に対象が移る
（ステップ実行）。Enterキーを押すたびに命令が実行され、それに従ってレジスタの中身が書き換わるのが確認できる。

`b 5`と入力し`Enter`を押すと、**マクロアセンブリ上での**5行目に到達するまで自動的にステップ実行が継続する
（（ﾅﾝﾁｬｯﾃ）ブレークポイント）。なおこの機能は`macro`から出力されたアセンブリでのみ有効である。

`m 10`と入力し`Enter`を押すと、メモリ番地0〜10に格納されている値を表示することができる。

`q`と入力し`Enter`を押すとデバッガが終了する。

DM上の初期配置を指定したい場合は`aqdb.sh`に`-m`オプションをつけて指定する
```
$ ./aqdb.sh ../examples/radix_sort1bit.s -m random.membin
```
先にファイル名を書き、後にオプションがくることに注意が必要である。

## ループ・アンローリング

繰り返し回数が予め分かっているループについてはループ・アンローリングを行うことでブランチ回数を減らすことができる。
マクロアセンブラをコピペして行ってもよいが、`erb`を使うと便利である。
すなわち[ERB](https://docs.ruby-lang.org/ja/latest/class/ERB.html)を用いてアセンブリを書き、
`macro`に入力する前に`erb`にフィルターする。詳細は`examples/radix4bit_insert_sort_with_muno.s`などを参照のこと。

## 独自ISA

現在のアセンブラやエミュレータはSIMPLE標準のISAにADDIとCMPIを追加したものになっている。
しかし（@anqou以外の他者が）実際に使用する際には、そもそもそのような命令を追加しなかったり、
追加場所が違うことが想定される。そのような場合には`src/{asm,emu}.c`を書き換えることで対処可能である。

その詳細については、SIMPLE-arch-toolsにADDI・CMPIを追加したときの[コミット](https://github.com/ushitora-anqou/SIMPLE-arch-tools/commit/61aa605d47c0b1e58979b088de666d6d0c29a138)
などを参考にしてほしい。`src/{asm,emu}.c`を書き換えることで、おおよそ全てのツールチェインが正常に動作するはずだ。

## `macro` で使える命令リファレンス

全く持って完備ではない。詳細はソースコードに当たること。

具体的な使い方は `examples/*.s` とか `src/test.sh` とかを調べると幸せになれるかもしれない。

凡例：

- `macroに食わせる入力`
    - `macroが吐く出力 or assemblerに食わせる入力`
    - 注意など

一般的に`Rn/Rm`はレジスタをさし`imm`は即値をさし、`label`はラベルをさす。
`imm`には10進数のほか`0x`を先頭につけることで16進数が、`0b`をつけることで2進数が使える。
2進数については、桁区切り文字として`'`が使える。

- `ADD Rn, Rm`
    - `ADD Rn, Rm`
    - `SUB`, `CMP`, `AND`, `OR`, `XOR`, `CMP`, `MOV`について同様。
- `ADD Rn, imm`
    - `ADDI Rn, imm`
    - `CMPI`について同様。
- `MOV Rn, imm`
    - `LI Rn, imm`
- `MOV Rn, [Rm + imm]`
    - `LD Rn, imm(Rm)`
    - `imm`は省略可能。`+`の代わりに`-`も使用可能。
- `MOV [Rn + imm], Rm`
    - `ST Rm, imm(Rn)`
    - `imm`は省略可能。`+`の代わりに`-`も使用可能。
- `Rn = Rm`
    - `MOV Rn, Rm`
- `[Rn + imm] = Rm`
    - `ST Rm, imm(Rn)`
- `Rn = [Rm + imm]`
    - `LD Rn, imm(Rm)`
- `SLL Rn, imm`
    - `SLL Rn, imm`
    - `SLR`, `SRL`, `SRA`について同様。
- `IN Rn`
    - `IN Rn`
    - `OUT`について同様。
- `HLT`
    - `HLT`
- `JMP label`
    - `B labelへの相対アドレス`
- `goto label`
    - `B labelへの相対アドレス`
- `JE label`
    - `BE labelへの相対アドレス`
- `JL label`
    - `BL labelへの相対アドレス`
- `JLE label`
    - `BLE labnelへの相対アドレス`
- `JNE label`
    - `BNE labelへの相対アドレス`
- `if Rn == Rm then goto label`
    - `CMP Rn, Rm（改行）BE labelへの相対アドレス`
    - `Rn == Rm` という条件が成立するときに`label`へ飛ぶようなアセンブリを出力する。なお`!=`の他`<`, `<=`についても同様。
- `define name body`
    - なし。
    - マクロを定義できる。すなわち、この行よりあとの全ての`name`は`body`に置換される。`examples/fibonmem_macro.s`などを参照のこと。
- `inline name (args...) { body... }`
    - なし。
    - 引数付きマクロを定義できる。すなわち、この行よりあとの全ての`name(args...)`は`body...`に置換される。自動的にlabel namespaceを付与するなどの機能がある。詳細は`examples/sort/*.s`やソースコードを参照のこと。

## バグかな？と思ったら

Issueをぶっ立てるか anqou に相談するかソースコード読んで自分で解決するかしてください。
自分で解決した場合はPull Requestを送ってもらえると私を含めSIMPLE-arch-toolsを使う
全ての人が助かります。
